C51 COMPILER V9.60.0.0   MIC2                                                              06/10/2020 01:05:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MIC2
OBJECT MODULE PLACED IN .\Objects\mic2.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil\C51\BIN\C51.EXE mic2.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\mic2.lst) TABS(2) OBJECT(.\Objects\mic2.obj)

line level    source

   1          #include <REGX52.H>
   2          #include <string.h>
   3          
   4          #define TRUE 1
   5          #define SERIAL_MODE P3_4  // 0 odbiór, 1 nadawanie
   6          #define MAX_BUF_SIZE 20   // max rozmiar bufora
   7          #define X 200             // parametry dla funkcji delay
   8          #define Y 200
   9          #define POWER_LEFT P2_0
  10          #define POWER_RIGHT P2_1
  11          
  12          /* -----------------ZMIENNE/STALE KOMUNIKACJI----------------- */
  13          
  14          // Komendy nadajace
  15          unsigned char code B_COMMAND1[] = "";
  16          
  17          // Komendy odbierane
  18          unsigned char code R_COMMAND1[] = "<2_display12>";
  19          
  20          // Bufor odbioru
  21          unsigned char data rcvBuf[MAX_BUF_SIZE] = {0};  
  22          
  23          // Licznik dla RcvBuf
  24          unsigned char data rcvIndex;
  25          
  26          /* -----------------ZMIENNE/STALE POZOSTALE----------------- */
  27          
  28          // Tablica buforow - dla obu wyswietlaczy
  29          unsigned char data buf[2];
  30          
  31          // Tablica cyfr 0 - 9
  32          unsigned char code NUMBERS[] = {0xBF, 0x86, 0xDB, 0xCF, 0xE6, 0xED, 0xFD, 0x87, 0xFF, 0xEF};
  33          
  34          unsigned char xdata right _at_ 0xFD00;
  35          unsigned char xdata left _at_ 0xFE00;
  36            
  37          /* -----------------FUNKCJE POMOCNICZE----------------- */
  38          
  39          extern void executeCommand();
  40          extern void clearRcvBuf();
  41          extern void delay();
  42          extern void send(unsigned char);
  43          extern void Init();
  44          
  45          /* -----------------PRZERWANIA----------------- */
  46          
  47          void ISR_INT0(void) interrupt 0
  48            {
  49   1          rcvIndex++;
  50   1        }
  51          
  52          // Przerwanie z portu szeregowego - odczyt danych
  53          void ISR_SERIAL(void) interrupt 4 { 
  54   1        
C51 COMPILER V9.60.0.0   MIC2                                                              06/10/2020 01:05:23 PAGE 2   

  55   1        if (RI == 1) {
  56   2          /*
  57   2          if (SBUF == '<') {
  58   2            clearRcvBuf();
  59   2          }
  60   2          if (rcvIndex > -1 && rcvIndex < MAX_BUF_SIZE) {
  61   2            rcvBuf[rcvIndex++] = SBUF;
  62   2            if (SBUF == '>') {
  63   2              executeCommand();
  64   2            }
  65   2          }
  66   2        */
  67   2        }
  68   1        RI = 0;
  69   1      } 
  70          
  71          /* -----------------PROGRAM GLOWNY----------------- */
  72          
  73          void main(void) {
  74   1      
  75   1        Init();
  76   1        
  77   1        while(TRUE) {
  78   2          left = NUMBERS[buf[rcvIndex]];
  79   2          right = NUMBERS[buf[1]];
  80   2        }
  81   1      }
  82          
  83          /* -----------------CIALA FUNKCJI POMOCNICZYCH----------------- */
  84          
  85          // Funkcja sprawdzajaca ktora komenda zostala odebrana
  86          void executeCommand(void) {
  87   1        
  88   1        unsigned char i = 0;
  89   1        unsigned char bufLength = 0;
  90   1        unsigned char correctFlag = 1;
  91   1        
  92   1        // R_COMMAND1
  93   1        bufLength = strlen(rcvBuf);
  94   1        while (i < bufLength && correctFlag == 1) {
  95   2          if (i == (bufLength - 3)) {
  96   3            buf[0] = rcvBuf[i];
  97   3          } else if (i == (bufLength - 2)) {
  98   3            buf[1] = rcvBuf[i];
  99   3          } else if (R_COMMAND1[i] == rcvBuf[i]) {
 100   3            // do nothing
 101   3          } else {
 102   3            correctFlag = 0;
 103   3          }
 104   2          i++;
 105   2        }
 106   1        buf[0] = 1 % 5;
 107   1        buf[1] = 1 % 10;
 108   1      }
 109          
 110          // Funkcja czysci zawartosc bufora odbiorcy
 111          void clearRcvBuf(void) {
 112   1        rcvIndex = 0; 
 113   1        for (rcvIndex; rcvIndex < sizeof(rcvBuf); rcvIndex++) {
 114   2          rcvBuf[rcvIndex] = '0';
 115   2        }
 116   1        rcvIndex = 0;
C51 COMPILER V9.60.0.0   MIC2                                                              06/10/2020 01:05:23 PAGE 3   

 117   1      }
 118              
 119          // Funkcja opozniajaca odczytywanie wcisnietych wartosci
 120          void delay(void) {
 121   1        int x = 0, y = 0;
 122   1        for (x; x < X; x++) {
 123   2          for (y; y < Y; y++) {;}
 124   2        }
 125   1      }
 126          
 127          // Funkcja wysylajaca dany znak przez magistrale
 128          void send(unsigned char value) {
 129   1        SERIAL_MODE = 1;              // tryb nadawania
 130   1        ES = 0;                       // wylaczenie nasluchu odbierania danych
 131   1        TI = 0;                       
 132   1        SBUF = value;                 // zaladuj znak do bufora
 133   1        while(TI == 0); 
 134   1        TI = 0;
 135   1        ES = 1;                       // ponowne wlaczenie nasluchu odbierania danych
 136   1        SERIAL_MODE = 0;              // tryb odbioru
 137   1      }
 138          
 139          // Funkcja inicjujaca
 140          void Init(void) {
 141   1        
 142   1        // USTAWIENIA OGOLNE
 143   1        SERIAL_MODE = 0;          // przejdz w tryb odbioru
 144   1        rcvIndex = 0;             // licznik bufora odbioru na 0
 145   1        SCON = 0x50;              // konfiguracja portu szeregowego
 146   1        T2CON = 0x30;             // konfiguracja Timera 2 
 147   1        RCAP2L = TL2 = 0xDC;      // konfiguracja predkosci nadawania i odbioru 
 148   1        RCAP2H = TH2 = 0xFF;      // danych przez port szeregowy
 149   1        TR2 = 1;                  // timer 2 => ON taktowanie portu szeregowego
 150   1        RI = TI = 0;              // gaszenie flag odbiornika i nadajnika
 151   1        ES  = 1;                  // wlacz przerwania z portu szeregowego
 152   1        EX0 = 1;                  // zalacz przerwanie od INT0
 153   1        IT0 = 1;                  // aktywnosc na zbocze opadajace H --> L
 154   1        EA  = 1;                  // wlacz maske przerwan
 155   1        
 156   1        // USTAWIENIA POZOSTALE
 157   1        buf[0] = 1;
 158   1        buf[1] = 2;
 159   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    250    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
